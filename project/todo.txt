Temat projektu: 

	Zaprojektować algorytm kosyntezy (algorytm konstrukcyjny) stricte na 
  podstawie standaryzacji ("normalizacji"), uwzględniając bieżący stan systemu, 
  czyli te czynniki globalne, które mogą aktualizować na bieżąco współczynniki 
  standaryzacyjne. Druga część projektu: zaimplementować algorytm do 
  przydziału nieprzewidzianych zadań.

Co już zrobiliśmy:

    1. Wymyśliliśmy wzory.
    2. Otrzymaliśmy odpowiedzi na pytania.
    3. Dodaliśmy szkielet (w tym ResourceAllocator).
    4. Utworzyliśmy plik z funkcjami i strukturami pomocnicznymi (utilities.hpp).
    5. Uruchomiliśmy podstawowy przydział zasobów bez aktualizacji 
    współczynników ani uwzględnienia zaalokowanych dotychczas zasobów.
    6. Dodaliśmy przeliczenie współczynników zgodnie ze wzorem na pęd.
    7. Dodaliśmy uwzględnienie przypadków, kiedy dziecko chce mieć zasób, 
    którego nie da się podpiąć do rodzica.
    8. Dodaliśmy do ResourceAllocator::allocate() rozważanie zaalokowanych
    dotychczas zasobów.
    9. Dodaliśmy ustalenie maksymalnego czasu i kosztu z poziomu powłoki.
    10. Utworzyliśmy testowy graf (modyfikacja test_structural_1.txt) o nazwie
    test_unpredicted.txt, w którym są dodane nieprzewidziane zadania.
    11. Zaimplementowaliśmy przydział nieprzewidzianych zadań na podstawie
    rozwiązania zadania #9 (przydział zgodnie z kryterium min(time * cost) i
    szeregowanie listowe. Podczas przydziału zadania nieprzewidziane nie mogą
    korzystać z jednostek specjalistycznych).

Co zostało do zrobienia:

    Utworzyć plik README + schemat, w którym bedą wszystkie wzory,
    przykładowe grafy, opis Flow całego algorytmu.

Uwagi:

  1. Całkowita liczba zasobów do zaalokowania jest szacowana, bo jest szansą,
  że skorzystamy z już dostępnych zasobów.
  2. Przy rozważaniu zaalokowanych dotychczas zasobów: wybieramy najlepsze 
  zgodnie z naszym wzorem standaryzacyjnym i potem patrzymy na to, które zasoby 
  są wolne teraz, a który wybraliśmy. Jeśli ten typ zasobu jest wolny w 
  momencie, kiedy rodzic zadania (o ile posiada, wpp: czas rozpoczęcia zadania
  jest równy 0) przejdzie do niego, to wybieramy dostępną kopię i wykonujemy 
  na nią. Jeśli nie, to kupujemy nowy zasób. Ostatnie przypadek występuje 
  zdecydowanie częściej, dlatego wynik działania naszego algorytmu 
  konstrukcyjnego może być służyć za punkt wyjścia dla algorytmu rafinacyjnego.
  3. Przydział nieprzewidzianych zadań z załozenia nie uwzględnia szyn
  komunikacyjnych (gdybyśmy uwzględniali to, to nie zawsze bylibyśmy w stanie
  wykonać nieprzewidziane zadania, poniewaz mozemy nie mieć połączeń między
  tymi zasobami, które są dostępne po usunięciu z listy dostępnych jednostek
  procesorów specjalistycznych. Takich problemów nie rozwazaliśmy na zajęciach).