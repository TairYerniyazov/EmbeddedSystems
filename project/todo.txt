Temat projektu: 

	Zaprojektować algorytm kosyntezy (algorytm konstrukcyjny) stricte na 
  podstawie standaryzacji ("normalizacji"), uwzględniając bieżący stan systemu, 
  czyli te czynniki globalne, które mogą aktualizować na bieżąco współczynniki 
  standaryzacyjne. Druga część projektu: zaimplementować algorytm do 
  przydziału nieprzewidzianych zadań.

Co już zrobiliśmy:

    1. Wymyśliliśmy wzory.
    2. Otrzymaliśmy odpowiedzi na pytania.
    3. Dodaliśmy szkielet (w tym ResourceAllocator).
    4. Utworzyliśmy plik z funkcjami i strukturami pomocnicznymi (utilities.hpp).
    5. Uruchomiliśmy podstawowy przydział zasobów bez aktualizacji 
    współczynników ani uwzględnienia zaalokowanych dotychczas zasobów.
    6. Dodaliśmy przeliczenie współczynników zgodnie ze wzorem na pęd.
    7. Dodaliśmy uwzględnienie przypadków, kiedy dziecko chce mieć zasób, 
    którego nie da się podpiąć do rodzica.
    8. Dodaliśmy do ResourceAllocator::allocate() rozważanie zaalokowanych
    dotychczas zasobów.
    9. Dodaliśmy ustalenie maksymalnego czasu i kosztu z poziomu powłoki.

Co zostało do zrobienia:

    1. Przydział nieprzewidzianych zadań (bazując na zadaniu 9.): nie ruszamy 
    HC. Operujemy na zasobach już zaalokowanych dotychczas i szeregujemy 
    listowo. Utworzyć kilka grafów testowych o nazwie 
    "data/test_unpredicted_#.txt".

    2. Utworzyć plik README + schemat, w którym bedą wszystkie wzory,
    przykładowe grafy, opis Flow całego algorytmu.

Uwagi:

  1. Całkowita liczba zasobów do zaalokowania jest szacowana, bo jest szansą,
  że skorzystamy z już dostępnych zasobów.
  2. Przy rozważaniu zaalokowanych dotychczas zasobów: wybieramy najlepsze 
  zgodnie z naszym wzorem standaryzacyjnym i potem patrzymy na to, które zasoby 
  są wolne teraz, a który wybraliśmy. Jeśli ten typ zasobu jest wolny w 
  momencie, kiedy rodzic zadania (o ile posiada, wpp: czas rozpoczęcia zadania
  jest równy 0) przejdzie do niego, to wybieramy dostępną kopię i wykonujemy 
  na nią. Jeśli nie, to kupujemy nowy zasób. Ostatnie przypadek występuje 
  zdecydowanie częściej, dlatego wynik działania naszego algorytmu 
  konstrukcyjnego może być służyć za punkt wyjścia dla algorytmu rafinacyjnego.